MyBatis
    是支持定制化SQL，存储过程以及高级映射的优秀持久层框架。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MBatis可以对配置和原生Map使用简单的XML或朱姐，将接口和Java的POJOs(Plain Old
    Java Objects普通的Java对象)映射成数据库中的记录

安装
    要使用MyBatis，只需要将mybatis-x.x.x.jar文件置于classpath中即可
    如果使用Maven来构建项目，则需要将下面的dependency代码置于pom.xml文件中:
    <dependency>
        <groupId>org.mybatis<groupId>
        <artifactId>mybatis</artifactId>
        <version>x.x.x</version>
    </dependency>

  从XML中构建SqlSessionFactory
      每个基于MyBatis的应用都是以一个SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。
   而SqlSessionFactoryBuilder则可以从XML配置文件互或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例。
      从XML文件中构建SQLSessionFactory的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的输入流(InputStream)实例,包括
   字符串形式的文件路径或者file://的URL形式的文件路径来配置。MyBatis   包含一二明教Resource的工具类，它包含一些实用的方法，可以从classpath
   或者其他位置加载资源文件更加容易。
   String resource = "org/mybatis/example/mybatis-config.xml";
   InputStream inputStream =  Resources.getResourceAsStream(resource);
   sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

   XML配置文件(configuration XML)中包含了对MyBatis系统的核心设置，包含获取数据库连接实例的数据源(DataSource)和决定事务范围和控制方式的
    事务管理器(TransactionManager)。

    XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务范围和控制方式的事务管理器（TransactionManager）。XML 配置文件的详细内容后面再探讨，这里先给出一个简单的示例：

    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE configuration
      PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
      "http://mybatis.org/dtd/mybatis-3-config.dtd">
    <configuration>
      <environments default="development">
        <environment id="development">
          <transactionManager type="JDBC"/>
          <dataSource type="POOLED">
            <property name="driver" value="${driver}"/>
            <property name="url" value="${url}"/>
            <property name="username" value="${username}"/>
            <property name="password" value="${password}"/>
          </dataSource>
        </environment>
      </environments>
      <mappers>
        <mapper resource="org/mybatis/example/BlogMapper.xml"/>
      </mappers>
    </configuration>
    当然，还有很多可以在XML 文件中进行配置，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，用来验证 XML 文档正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则是包含一组 mapper 映射器（这些 mapper 的 XML 文件包含了 SQL 代码和映射定义信息）。

    不使用 XML 构建 SqlSessionFactory
    如果你更愿意直接从 Java 程序而不是 XML 文件中创建 configuration，或者创建你自己的 configuration 构建器，MyBatis 也提供了完整的配置类，提供所有和 XML 文件相同功能的配置项。

    DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();
    TransactionFactory transactionFactory = new JdbcTransactionFactory();
    Environment environment = new Environment("development", transactionFactory, dataSource);
    Configuration configuration = new Configuration(environment);
    configuration.addMapper(BlogMapper.class);
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);
    注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射语句的注解从而避免了 XML 文件的依赖。不过，由于 Java 注解的一些限制加之某些 MyBatis 映射的复杂性，XML 映射对于大多数高级映射（比如：嵌套 Join 映射）来说仍然是必须的。有鉴于此，如果存在一个对等的 XML 配置文件的话，MyBatis 会自动查找并加载它（这种情况下， BlogMapper.xml 将会基于类路径和 BlogMapper.class 的类名被加载进来）。具体细节稍后讨论。

    从 SqlSessionFactory 中获取 SqlSession
    既然有了 SqlSessionFactory ，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：

    SqlSession session = sqlSessionFactory.openSession();
    try {
      Blog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);
    } finally {
      session.close();
    }
    诚然这种方式能够正常工作，并且对于使用旧版本 MyBatis 的用户来说也比较熟悉，不过现在有了一种更直白的方式。使用对于给定语句能够合理描述参数和返回值的接口（比如说BlogMapper.class），你现在不但可以执行更清晰和类型安全的代码，而且还不用担心易错的字符串字面值以及强制类型转换。

    例如：

    SqlSession session = sqlSessionFactory.openSession();
    try {
      BlogMapper mapper = session.getMapper(BlogMapper.class);
      Blog blog = mapper.selectBlog(101);
    } finally {
      session.close();
    }


    探究已映射的sql语句
        映射的两种实现方式： 1)xml实现
                         2)注解实现
        java实现的两种方式
                         1)完全限定名的形式
                           Blog blog = (Blog)session.selectOne(org.mybatis.example.BlogMapper.selectBlog",101)
                         2)类中调用的方式
                           BlogMapper mapper = session.getMapper(BlogMapper.class);
                           Blog blog = mapper.selectBlog(101)
        SqlSessionFactoryBuilder

        这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳范围是方法范围（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。

        SqlSessionFactory

        SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳范围是应用范围。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。

        SqlSession

        每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的范围是请求或方法范围。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理范围中，比如 Serlvet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的范围中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式：

        SqlSession session = sqlSessionFactory.openSession();
        try {
          // do work
        } finally {
          session.close();
        }
        在你的所有的代码中一致性地使用这种模式来保证所有数据库资源都能被正确地关闭。

        映射器实例（Mapper Instances）

        映射器是创建用来绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，映射器实例的最大范围是和 SqlSession 相同的，因为它们都是从 SqlSession 里被请求的。尽管如此，映射器实例的最佳范围是方法范围。也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可废弃。并不需要显式地关闭映射器实例，尽管在整个请求范围（request scope）保持映射器实例也不会有什么问题，但是很快你会发现，像 SqlSession 一样，在这个范围上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法范围（method scope）内。下面的示例就展示了这个实践：


    XMl配置文件
        属性(properties)
        设置(settings)
        类型别名(typeAliases)
        类型处理(typeHandlers)
        对象工厂(objectFactory)
        插件(plugins)
        环境配置(environments)
        数据库厂商标识(databaseIdProvider)
        映射器


   XML映射文件
        MyBatis的正真强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的XML文件就显得相对简单。如
        SQL映射文件有很少的几个顶级元素
        cache-给定命名空间的缓存配置
        resultMap-是最复杂也是最强大的元素，用来描述如何从数据库结果集中加载对象
        sql-可被其他语句引用的可重用语句块
        insert-映射插入语句
        update-映射更新语句
        delete-映射删除语句
        select-映射查询语句


        <select id="selectPerson" parameterType="int" resultType="hashmap">
          SELECT * FROM PERSON WHERE ID = #{id}
        </select>
        这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。

        注意参数符号：

        #{id}
        这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：

        // Similar JDBC code, NOT MyBatis…
        String selectPerson = "SELECT * FROM PERSON WHERE ID=?";
        PreparedStatement ps = conn.prepareStatement(selectPerson);
        ps.setInt(1,id);





