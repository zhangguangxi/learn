JVM内存模型以及垃圾算法
    内存类型:NEW(年轻代)、Ternured(年老代) Perm(永久代)
    堆内存(运行时内存):NEW 、Ternured 从JVM启动参数-Xmx 指定的内存中分配
    栈内存(非运行时内存):Perm  由虚拟机直接分配  -XX:permsize   -XX:MaxPermSize

    年轻代(New):用来存放JVM刚分配的Java对象
    年老代(Tenured):年轻代中经过垃圾回收没有回收掉的对象将被Copy到年老代
    永久代(Perm):永久代存放Class,Method元信息,其大小跟项目的规模、类、方法的量有关，一般设置为128就足够，设置原则是预留30%的空间


New又风味几个部分
    Eden:存放JVM刚分配的对象
    survivor1
    survivro2:两个Survivor空间一样大，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回copy，当满足某个条件，比如copy次数，就会被copy到Tenured
              显然Survivor只是只能加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性

    垃圾回收算法:分为三类,都是基于标记-清除(复制)算法
                 串行算法
                 并行算法
                 并发算法





    JVM会根据机器的硬件配置对每个内存代选择适合的算法，比如，如果机器多于1个核，会选择对年轻代选择并行算法


    注意:并行算法 用多线程进行垃圾回收，回收期间会暂停程序的执行
         并发算法 也是多线程，但期间不停止应用执行。所以并发算法使用与交互性高的程序
         并发算法较少年轻代的大小，其实就是使用了一个大的年老代，这反过来跟并行算法相比吞吐量相对较低。

     垃圾回收动作合适执行
          当年轻代内存满时，会引发一次普通GC，该GC仅仅回收年轻代。需要强调的是，年轻代是指Eden代满时
          当年老代满时会引发Full Gc，Full Gc将同时回收年轻代、年老代。
          当永久代满时也会引发Full Gc 会导致Class Method元信息的卸载

     另外一个问题是，合适跑出OutOfMemoryException，并不是内存被耗空的时候才抛出
      JVM98%的时间都花费在内存回收
      每次回收的内存小于2%

二、内存泄漏及解决方法
      1、系统崩溃前的一些现象
         每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、 s
         FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC
         年老代的内存越来越大并且每次FullGC后年代没有内存释放



       2、生成堆的dump文件
            通过JMX的MBean生辰的当前的Heap信息，大小为一个3G(整个堆得大小)的hprof文件，如果启动JMX可以通过java的jmap命令来生成该文件


       3、分析dump文件
          1、Visulal VM
          2、IBM HeapAnalyzer
          3、jdk自带的hprof工具
            上述上中工具都有一定的局限，最后可以选择Eclipse专门的静态分析工具
            通过Mat或者JMX我们还可以分析线程状态，可以观察线程被阻塞在哪个对象上。

参考文章：
http://blog.csdn.net/chen77716/article/details/5695893




















































